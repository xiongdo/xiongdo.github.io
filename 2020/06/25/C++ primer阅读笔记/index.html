<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  

  
  <title>C++ primer阅读笔记 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="第II部分流流的状态可以通过rdstate获取，获取到的状态可以用位运算来提取不同类型的状态值。 缓冲刷新表示缓冲区数据做了输出。 对于iostream来说，最重要的是流的状态如何获取和改变。对于fstream最重要的是要知道打开文件的时候对应的状态。对于sstream来说，最重要的是要知道什么时候使用它们最方便。 顺序容器：主要需要考虑在什么情况下使用什么应用场景下使用什么类型的容器。书中介绍了">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ primer阅读笔记">
<meta property="og:url" content="http://yoursite.com/2020/06/25/C++%20primer%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="第II部分流流的状态可以通过rdstate获取，获取到的状态可以用位运算来提取不同类型的状态值。 缓冲刷新表示缓冲区数据做了输出。 对于iostream来说，最重要的是流的状态如何获取和改变。对于fstream最重要的是要知道打开文件的时候对应的状态。对于sstream来说，最重要的是要知道什么时候使用它们最方便。 顺序容器：主要需要考虑在什么情况下使用什么应用场景下使用什么类型的容器。书中介绍了">
<meta property="og:locale" content="ch">
<meta property="article:published_time" content="2020-06-25T07:25:38.993Z">
<meta property="article:modified_time" content="2020-06-25T07:52:08.045Z">
<meta property="article:author" content="xiongdo">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-C++ primer阅读笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/25/C++%20primer%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2020-06-25T07:25:38.993Z" itemprop="datePublished">2020-06-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      C++ primer阅读笔记
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="第II部分"><a href="#第II部分" class="headerlink" title="第II部分"></a>第II部分</h1><h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><p>流的状态可以通过rdstate获取，获取到的状态可以用位运算来提取不同类型的状态值。</p>
<p>缓冲刷新表示缓冲区数据做了输出。</p>
<p>对于iostream来说，最重要的是流的状态如何获取和改变。对于fstream最重要的是要知道打开文件的时候对应的状态。对于sstream来说，最重要的是要知道什么时候使用它们最方便。</p>
<h2 id="顺序容器："><a href="#顺序容器：" class="headerlink" title="顺序容器："></a>顺序容器：</h2><p>主要需要考虑在什么情况下使用什么应用场景下使用什么类型的容器。书中介绍了如下几条原则：</p>
<ul>
<li>除非有更好的理由，不然选择vector容器。</li>
<li>对于需要任意位置插入元素的情况往往发生在输入数据过程中，因此可以用list先读取数据，结束之后再将数据放入vector。</li>
<li>另一些情况如果只是对排序有要求，可以用vector输入数据，再用标准库sort函数实现排序，避免对数据的随机插入。</li>
</ul>
<p>C seq(n)的构造函数是explicit的。  </p>
<p>Assign操作会导致迭代器，指针，引用失效，而swap不会，但是string和array两种顺序容器除外。    </p>
<p>所有顺序容器都支持相等运算符和大小运算符。规则主要是：</p>
<ul>
<li>大小相同且每个元素都相同，那么相等。</li>
<li>大小不同，且小的是大的的前缀，则小的小于大的。</li>
<li>互不为前缀，则比较第一个不相同元素大小。  且关系运算符能够使用取决于容器元素是否支持关系运算符操作。  </li>
</ul>
<p>顺序容器初始化，如果容器元素没有默认构造函数，则需要传入一个初始化值给两个参数的构造函数。    </p>
<p>对于顺序容器的插入操作，需要特别考虑array和forward_list两种容器，array不支持任何插入操作，forwar_list支持的各种插入操作都是独特的。   </p>
<p>对于不支持push_front操作的容器，可以使用c.insert(c.begin(), args)的方法从前插入，但是可能很耗时。</p>
<p>while(std::cin &gt;&gt; word)  iter = lst.insert(iter, word);</p>
<p>调用顺序容器的front和back需要先判断容器是否非空。向vector，deque，string中插入元素，会使得所有指向容器的迭代器、引用和指针失效。删除deque中除首位元素之外的任何元素，会使得所有指向容器的迭代器、引用、指针失效，删除vector、string中的任何元素，会使得迭代器、引用、指针失效。</p>
<p>使用容器的迭代器、引用、指针需要仔细考虑迭代器、指针、引用失效的情况。</p>
<p>对于vector来说，只有当加入元素超出了capacity()返回的大小时，它才会重新分配内存空间。</p>
<p>对于string容器来说，支持很多独特的操作来方便对字符串的使用。</p>
<p>标准库还定义了stack、queue、priority_queue三个适配器。</p>
<h2 id="泛型算法："><a href="#泛型算法：" class="headerlink" title="泛型算法："></a>泛型算法：</h2><p>泛型算法实现了将容器与操作分离，使得对不同容器进行操作的行为，转化为对不同容器的迭代器进行操作，其实本质是对每个算法所需要的最低数据结构要求抽象出来，然后将这一要求化为对迭代器的要求，因此不同的容器只要满足某些条件，就可以使用某一些泛型算法。这种方式类似于数学定理往往抽象出某一条件的充分必要条件，因此对一个定理的应用，需要先验证前提是否满足，类似泛型算法验证容器是否支持随机访问、向后迭代等行为。</p>
<p>将标准库的算法进行分类，主要可以分为只读算法、写容器元素的算法、重排容器的算法三种类型。其中需要注意的是fill_n不检查容器的空间，若空间不足，其行为是未定义的。</p>
<p>为了定制算法的谓词，可以使用lambda表达式。Lambda表达式必须包含捕获列表和函数体，其余内容可以没有。对于lambda来说，其捕获的变量列表是在定义它的时候就被拷贝的，因此若非引用，则在定义lambda之后其捕获列表的值不会发生变化。在易于避免错误的原则下，应该尽量少捕获指针或者引用。事实上，可以使用[=]来让编译器自身决定捕获列表，若混用隐式捕获和显式捕获，则显示和隐式应该采用不同的捕获类型（引用捕获，值捕获），且隐式要写在前面。若在lambda种会改变捕获的变量，则应该在参数列表之后加入mutable关键字。</p>
<p>解决上一段问题的另一个方法是标准库的bind函数，这个函数可以对已经存在的函数进行参数定制，绑定固定的参数或者修改参数的顺序，生成一个新的可调用对象（函数，函数指针，lambda，重载了调用运算符的类型）。Bind和lambda一样，绑定参数时默认是值拷贝，对于不能拷贝的类型，应该是用标准库ref函数生成一个对象的引用，或者用cref生成一个const的引用。</p>
<p>流迭代器可以像使用迭代器那样使用流，因此也可以在流上使用泛型算法。定义流迭代器时必须确定迭代器的类型，一次来确定从流中读取或者输出的类型。输出流迭代器对解引用和++运算符都不做任何事，但是在使用时还是可以加上保持和其他迭代器使用的一致性。</p>
<p>事实上根据不同泛型算法对迭代器支持操作要求的不同，可以将迭代器分成五个类型：输入迭代器，输出迭代器，前向迭代器，双向迭代器和随机访问迭代器。这五种不同类型的迭代器适用于不同类型的算法，在对迭代器使用算法的时候，需要首先考虑算法需要的操作是否被迭代器所满足。</p>
<h2 id="关联容器："><a href="#关联容器：" class="headerlink" title="关联容器："></a>关联容器：</h2><p>关联容器是键值对的集合，标准库中有两种类型的关联容器，有序关联容器和无序关联容器。</p>
<p>使用关联容器需要先注意什么类型可以作为容器的关键字类型。对于有序容器来说，需要关键字类型满足严格弱序，其实就是数学上的良序集。并且在上面有定义关系运算符。如果没有关系运算符，则需要自定义比较函数，这在定义关联容器的开始就需要传入比较函数的类型。</p>
<p>Map迭代器对于关键字是const的，无法改变关键字值，对于set来说，它只有关键字所以它的迭代器是强制const的无论声明使用const还是非const。</p>
<p>另外，与顺序容器不同，通常不在关联容器迭代器上使用泛型算法，因为关联容器的迭代器对于关键字往往是const的。另外有一些特有的关联容器方法实现比泛型算法更快，它适应了关联容器的底层结构。</p>
<p>向map插入元素可以在参数列表直接构建pair类型，在新标准下构建pair类型最简单快速的方法就是使用花括号，例如{“hello”, 1}。</p>
<p>c.emplace方法在map和multimap中的表现不同，对于map返回pair包含迭代器和结果，对于multimap直接返回指向结果的迭代器。</p>
<p>使用索引方式访问map时，如果关键字还未添加到map中，则会创建并初始化，如果添加了则会直接返回value。但是使用at来访问下标的时候，若关键字不存在则会抛出一个out_of_range异常。</p>
<p>总结来说查找关联容器的元素的方法主要提供了这几种：下标访问，这种方式可能会改变容器。At方法，这种方式可以在不改变容器的基础上返回容器中的元素，但是若索引不存在则会导致程序异常。Find函数，返回指向查找元素的迭代器，这种方法对于关键字可以重复的关联容器返回的迭代器指向第一个满足关键字的容器。Upper_bound, lower_bound和equal_range这两个方法返回的时迭代器范围，更适用于在无序容器中查找元素。</p>
<p>在有序关联容器中，元素之间具有序的关系，但是在无序容器中没有，无需容器是基于hash设计的。</p>
<h2 id="动态内存："><a href="#动态内存：" class="headerlink" title="动态内存："></a>动态内存：</h2><p>C++11新标准中定义了智能指针，来帮助程序员更好地预期动态内存的行为，它的实现主要是基于引用计数</p>
<p>Share_ptr所指向的对象，当其不在被程序当中任何share_ptr所引用的话，它就会被释放，但是当其位于容器中，必须使用earse擦除这一个对象才会被释放。</p>
<p>直接使用new和delete来管理动态内存存在一定的缺陷，因为在程序中查找所有指向同一块内存的指针往往是困难的，这就通常会导致一些指针指向已经被释放的内存，从而导致对释放掉的内存的引用。</p>
<p>内置指针与智能指针之间不能隐式转换，因为接受内置指针参数的智能指针构造函数时explicit的。并且必须注意智能指针只能使用指向动态内存的指针初始化，因为指向栈空间的指针不能被调用delete。</p>
<p>混用智能指针和内置指针往往很危险，因为内值指针不会增加智能指针所指向对象的引用计数，因此可能导致智能指针将动态内存提前释放，产生一个空悬的内值指针。</p>
<p>智能指针对函数内异常有较好的适应能力。若在某一个函数内存分配了一个智能指针，且函数中抛出了一个异常，且异常不在函数内被捕获，则异常不会导致智能指针所指向的内存不被释放。而内置指针可能会导致所指向的内存泄漏。</p>
<p>根据智能指针的实现，每一次用内置指针初始化一个智能指针的时候，都会新建一个引用计数对应这个智能指针所指向的对象。如果用一个内值指针多次初始化同一个智能指针，可能会导致变量被意外的销毁。</p>
<p>int* p = new int(32);<br>    std::shared_ptr<int> sp1(p);//引用计数对于sp1来说此时是1<br>    {<br>        std::shared_ptr<int> sp2(p);//引用技术对于sp2来说此时是2<br>}//离开sp2的作用域导致sp2释放掉它所指向的内存<br>//此处p和sp1都是空悬指针了。</p>
<p>Weak_ptr可以用来监视share_ptr的使用情况，常用来与share配合使用，weak与share的不同在于，它不会增加引用计数，因此不会对资源是否释放产生影响。其实这两种智能指针的实现都依赖于一个计数类，每当使用一块内存第一次被一个share指向时，久会开辟一个计数类空间，其中保存了指向这一块内存的weak指针和share指针数量。且weak类和share类当中都存有这一块计数类的地址。只有当这个计数类的两个计数值都为0时，ta 才会被释放掉。另外，weak也会被用在避免循环引用无法释放内存的情况下。</p>
<p>C++支持对动态数组的申请和释放，但是在大多数场合下要首先考虑使用容器而不是手动申请动态数组。</p>
<p>Typedef int arr[42]这个声明定义了一个数组类型，但是当用new申请新得arr变量时，返回得是一个指针而不是一个数组，无法对一个指针使用begin和end等一系列迭代器操作，事实上这样申请得到得指针所指向得数组维度是不可见得，而数组维度是数组本身得一部分（这也是指针和数组的一个区别）。</p>
<p>New关键字可以申请一个长度为0的动态数组，但是返回的变量是一个与任何其他指针都不相同的指针。它表现得像一个尾后迭代器一般。</p>
<p>因为new和delete关键字都将内存分配/内存释放和构造/析构结合在了一起，这导致再某些情况下并不适用，尤其是对于没有默认构造函数的类型，将无法使用new操作符申请动态数组，同时也无法给new操作符传入一个初始化器。因此C++标准库定义了一个allocator类型，可以构造一个内存分配器。</p>
<p>另外，可以用unique_ptr来管理动态申请的数组，只要将它定义为unique<T []>的类型，此时当调用reset时，会自动使用delete[]来释放存储指针的内存，而对于share_ptr则需要在初始化是自定义deleter删除器才行。</p>
<h1 id="第III部分"><a href="#第III部分" class="headerlink" title="第III部分"></a>第III部分</h1><h2 id="拷贝控制："><a href="#拷贝控制：" class="headerlink" title="拷贝控制："></a>拷贝控制：</h2><p>对一个类类型来说，C++没有直接定义它们发生拷贝时候的行为。当需要定义一个新的对象时，有的时候可以使用直接初始化的方法，这相当于通过参数匹配调用拷贝构造函数。另外通过赋值的方式创建一个新对象时，则是使用拷贝构造函数。拷贝构造函数是只接受对象的引用类型参数的构造函数，它会被编译器在如下几种情况中调用：1、使用=赋值到同类型对象中时。2、将一个对象作为实参传递给一个非引用类型的形参时。3、从一个返回类型为非引用类型的函数返回一个对象时。4、用列表初始化一个数组中的元素时。同时，将一些泛型算法作用于容器时也有可能会调用一些列构造函数，使用push和insert会调用拷贝构造函数进行初始化，而调用emplace时则是使用直接初始化。</p>
<p>拷贝赋值运算符，标准库要求保存在容器中的类型要具有赋值运算符，且其返回值要是左侧运算对象的引用。拷贝赋值运算符于拷贝构造函数的行为相似，但是拷贝赋值运算符可以在非创建对象的时候被调用，而拷贝构造函数只会在对象被创建的时候才会使用。</p>
<p>对构造函数和析构函数的解析：构造函数和析构函数这两种函数都分为两个部分，一个部分是对类型的成员进行初始化的部分，一个是函数体部分。对于构造函数来说，成员的初始化发生在函数体执行之前，对于析构函数来说，成员的销毁发生在函数体之后。因此，在执行构造函数的函数体之前，对象的成员就已经被初始化完毕了。</p>
<p>对于什么样的类需要拷贝构造函数，拷贝赋值运算符和析构函数，则可以参考三/五法则。</p>
<p>当希望C++编译器生成一个默认版本的构造函数时，可是使用=default关键字，若在类内声明时使用这一关键字，则会导致函数被声明为内联函数，因此若希望函数是外联的，则需要在类外使用关键字=default。</p>
<p>一个类的合成构造函数可能是删除的，当类内某个成员的析构函数是删除的或者不可访问的，或是类有一个引用成员，它没有类内初始化器具，或是类有一个const成员，他没有类内初始化器且其类型未显式定义默认构造函数。</p>
<p>在新标准发布前，为了阻止一些类的拷贝和赋值操作，在不能使用delete关键字的条件下，会将其声明为private的，并且不对其进行定义，因此用户代码将无法访问到成员函数，而另一方面，友元和其他成员函数对其的访问也将会在编译链接时遇到一个符号错误。</p>
<p>对于一些分配了动态资源的类型，可以为其特别定义一个swap函数来优化它在标准swap函数下的表现。</p>
<p>在定义分配了资源的类型的赋值运算符时，必须要防范自赋值操作，因此要在函数内，先拷贝右侧对象资源的副本，然后再将左侧对象的资源销毁，防止左侧和右侧对象指向同一片资源。</p>
<p>标准库的移动构造函数可以保证类型所管理的内存尽量被移动而不是重新分配和复制，当无法移动时，等价于拷贝构造函数。且移动构造函数保证，移动的源类型是可以被安全的析构的。</p>
<p>C++11定义了一个新的引用类型，右值引用。其可以绑定到临时对象上，但是不能和返回左值的表达式或者类型绑定。起作用与通常的引用相反。另外需要注意，即使是右值引用变量表达式也是左值，因此不能将一个右值引用绑定到一个右值引用上面。</p>
<p>对于一个左值，可以使用std::move来获得它的右值引用，但是这一行为之后，移后源将不能在使用它的值，但是可以对它重新赋值，源的内存并没有被释放。</p>
<p>标准库std::move其实相当于将一个变量的值取出来形成一个右值，然后源被释放。</p>
<p>与拷贝控制函数不太一样，移动控制函数在类型定义了任何一个拷贝控制函数时，移动控制函数就不会被合成，但是对于没有定义自己的拷贝控制函数的类型，如果其所有非static成员都是内置类型或者定义了移动控制函数的类型，则编译器会为其生成一个移动构造函数和移动赋值函数。<br>移动构造函数不会被隐式的被定义为删除的，当把他设置为default时，根据与拷贝构造函数差不多的原则，它有可能会被定义为删除的。另外，当一个类定义了移动构造函数和移动赋值运算符时，该类的合成拷贝构造函数和拷贝赋值运算符被定义为删除的。</p>
<p>类型中具有相同参数列表和名称的成员函数必须要么都加上引用限定符，要么都不加引用限定符。</p>
<h2 id="重载运算与类型转换"><a href="#重载运算与类型转换" class="headerlink" title="重载运算与类型转换"></a>重载运算与类型转换</h2><p>重载运算符虽然定义方式类似与函数，但是在其参数不能有默认的。另外对于重载运算符比较重要的是，重载运算符的调用本质是一次函数调用，因此如果重载了&amp;&amp;或者||这些运算符，他们的短路属性不会被保留。</p>
<p>通常情况下不应该重载逗号，取地址，逻辑与和逻辑或运算符。</p>
<p>重载算术运算符时，算术运算符是返回零时值，且一般定义算数运算符一定也会定义对应的复合赋值运算符，所以可以用复合赋值运算符来定义重载的算数运算符。</p>
<p>如果类含有判断两个元素是否相等的操作，则应该定义一个相等运算符。且相等运算符和不相等运算符应该互相定义，其中某一个的定义应该委托给另外一个运算符。同样的关系运算符也可以应用这种思路。当对于一些类来说，并不一定可以在上面定义良序关系，对于这样的类，不一定非要定义关系运算符。</p>
<p>下标运算符为了可以让其出现在赋值运算符的任意一端，一般会让它返回访问元素的引用。但是对于常量对象，返回一个常量的引用也是有必要的。</p>
<p>递增和递减运算符的后置版本，会提供一个额外的不被使用的int形参，这个参数主要用来区分前置还是后置。</p>
<p>重载箭头运算符的调用过程和普通的重载调用不同。如果调用的是一个指针，则相当于传统的应用方式。如果是一个重载了箭头运算符的类对象，则会调用类的箭头运算符，根据返回结果判断是当作指针继续使用箭头运算符还是重新调用重载的箭头运算符。因此，当我们重载箭头运算符时，应该要保证一层一层的解析最终会有结果，也即总会返回一个指向某类型的指针类型的变量。</p>
<p>类可以定义函数调用运算符，这会让对象使用起来像是函数一般。另外重载不同版本的调用运算符可以让函数调用运算符工作在不同的参数之上。<br>有lambda定义的类型，通产不具有默认的构造函数、赋值运算符和默认析构函数，对于是否具有默认的拷贝和移动构造函数则可以参考上一章的拷贝控制，是根据成员类型来确定的，若成员当中具有引用指针迭代器则没有默认的拷贝构造函数。</p>
<p>总结一下：C++中所有的可调用对象包含有：函数、函数指针、lambda表达式、bind创建的对象、以及重载了函数调用运算符的类。</p>
<p>不同的可调用对象可能具有完全不同的类型，例如lambda在每一次定义时，编译器都会为其生成一个新得未命名类型，这个类型只有它这一个对象。虽然类型可能不同，但是不同得可调用对象可能具有相同得调用形式，调用形式只由形参类型和返回值类型决定。定义调用形式的方式可以使用声明式，也可以使用标准库的function模板，它可以生成一个某一种调用形式的类型，并定义该类型的对象。</p>
<p>类型转换运算符通常被定义为类的成员函数，且不改变类的成员，因此定义为const成员。</p>
<p>虽然编译器一次只能执行一个用于定义的类型转换，但是却可以执行一次内置类型转换和一次用户定义类型转换。但是对于类型来说，除非具有非常明确的类型转换意义，才有必要隐式的定义类型转换运算符，对于其余情况应该避免使用类型转换运算符。但是往往对于bool类型的转换还是有必要的。但是对于某些情况下，不希望类型转换隐式的发生，可以定义显式的类型转换运算符。但是在条件表达式当中，即便是显示的类型转换也会被隐式的调用。这些条件表达式主要包含在：if, while, do, for, !, ||, &amp;&amp;, ?:运算符或者语句当中。</p>
<p>另外对于类型转换运算符来说，如果A类定义了从B类而来的隐式构造函数，而B类定义了转换为A类的隐式类型转换。则编译器将无法判断使用哪一种用户定义的类型转换函数。另一种二义性是当我们定义的多个类型转换所对应的类型之间有内置的类型转换方法。例如同时定义int和double的类型转换成员将会带来问题。</p>
<p>编译器在对参数进行匹配的过程中，是不会考虑可能会出现的标准类型转换的，如果存在两种可能的匹配都需要用户定义的类型转换，且都可以完成，则它们是一样好的，无论过程中有没有出现标准类型转换。因为我们知道编译器进行隐式转换的时候可以进行一次标准类型和一次用户定义类型。</p>
<p>二义性的问题在重载运算符时会表现得更广泛。因为重载运算符的时候无法区分是调用成员函数还是非成员函数，它们都会被加入到候选调用对象中。如果我们对同一个类即提供了转换目标是算术类型的类型转换，也提供了重载的运算符，则将会遇到重载运算符与内置运算符的二义性问题。</p>
<h2 id="面向对象的程序设计"><a href="#面向对象的程序设计" class="headerlink" title="面向对象的程序设计"></a>面向对象的程序设计</h2><p>面向对象的核心思想是抽象、继承和动态设计。动态绑定也称为运行时绑定，它是在运行时根据对象的继承关系决定当前到底要调用函数的何种版本，这一功能的实现主要是依赖虚函数的设计。如果基类讲一个函数声明成虚函数，则在其派生类当中函数也隐式的是虚函数。</p>
<p>派生类不一定有资格访问所有基类的成员，但是有一些成员对于基类来说，希望派生可以访问而其他用户不能访问，则可以在基类中将这些成员声明为protected的。另外派生列表声明为public时，可以使用基类的指针和引用来绑定派生类的对象。</p>
<p>派生类到基类的类型转换会由编译器隐式地执行。虽然派生类和基类的关系非常紧密，但是派生类不能在构造函数中直接初始化它的基类部分，而是必须将工作委托给基类的构造函数。一般来说初始化执行的顺序是，基类构造函数，派生类数据成员，派生类构造函数体。对于基类的成员，如果继承列表是由public修饰的，那么就可以在派生类对象中访问基类部分的public成员和protected成员，并且直接修改他们，但是最好不要这么做，而是通过访问基类接口的方式。Static遵循相同的访问控制手段。</p>
<p>对于一个派生类的声明不需要包含它的继承列表。必须继承自一个已经定义的类，而不仅仅只是声明，因此一个类不能派生自它自己。</p>
<p>C++11允许定义一个不能被继承的类，只需要在类的名字后面加上final关键字。</p>
<p>在c++中动态类型和静态类型不同的唯一情况就是该变量是一个指针或者引用。</p>
<p>当用一个派生类对象去构造或者赋值一个基类对象时，只有派生类的基类部分会被拷贝、移动或者赋值，它的派生部分将会被忽略掉。</p>
<p>虚函数引发的动态绑定效果只有通过引用或者指针来调用虚函数时才会发生。派生类中的虚函数必须在调用形式上和基类完全一致，除非它的返回类型是类本身的指针或者引用。另外一方面，最好使用override关键字修饰覆盖基类的虚函数，因为这样可以让编译器帮我们检查是否出现了函数调用形式上的错误。另外也可以把一个虚函数定义为final的，这样在派生类当中它将不会被覆盖。如果虚函数有默认实参则，使用默认调用时，将根据静态类型的默认实参进行调用。因此最好在派生类和基类当中使用相同的默认实参。另外，若要回避动态绑定的效果，可以使用作用域运算符。</p>
<p>继承列表的说明符不代表派生类当中对基类成员的访问控制，而是代表了派生类用户对基类成员的访问控制。同时也代表了派生类中继承自基类的成员在派生类当中的访问控制类型，如果说明符是private则所有基类成员在派生类当中都是private的，这回影响到再次继承。如果是public则与基类保持一致。</p>
<p>在一个类内定义一个友元其实就是说，在编写这个友元函数的代码时，就好像在编写这个类的成员函数一样，享有和成员函数一样的特权，例如访问私有成员，受保护成员等。所以一个友元函数如果只是派生类而不是基类的，则他不能在函数内部访问基类的私有成员，因为在派生类的成员函数内也不可以，所以关于友元函数的相关性质只要参考编写成员函数时的方式就可以容易的记住。</p>
<p>对于继承与访问控制来说，派生类中的友元没有对基类中受保护成员的特殊访问权限，派生类的友元函数就仅仅只是派生类的友元函数而已，它并不是基类的友元函数，派生类的友元函数只能通过派生类对象来访问基类中的受保护部分。但是基类的友元对于派生类对象中的基类私有成员仍然具有访问权限。另外需要注意的是，所有的友元不具有传递性。类的友元类的友元类不是原类的友元类。类的友元类的友元函数，也不是原类的友元函数。</p>
<p>Struct和class关键字的仅有两个不同之处在于，class的成员是默认private的，而struct的成员是默认public的，class的默认继承是private的，而struct相反。</p>
<p>因为类的成员调用首先发生的是名字的检查，所以当一个基类有同名虚函数的重载版本时，如果派生类只覆盖了其中的某一个，则当派生类对象调用另一个虚函数的版本时，编译器检查名字定位到了派生类，但是由于继承类当中只有一个版本的函数，则会发生参数不匹配的错误。因此使用using说明符保证基类的所有重载都对派生类可见。</p>
<p>一般在需要继承的场景下，把析构函数声明为虚的，是的不同动态类型可以调用对应的正确的析构函数版本。</p>
<p>任何派生类中的构造和赋值操作都需要显式地调用基类的相应操作才可以保证基类部分得到相应的初始化或者赋值。</p>
<p>在构造函数和析构函数内调用虚函数都是调用函数本身所属的那个类型的版本。</p>
<p>基类的构造函数可以在派生类中使用using说明符被继承。事实上继承的效果相当于编写一个完全委托给基类构造函数的构造函数，对于派生类特有的成员，将被执行默认的初始化。</p>
<p>对于容器来说，应该将容器的类型声明为存放基类的指针，不然派生类存放进容器时会忽略掉它的派生类部分。</p>
<h2 id="模版与泛型编程"><a href="#模版与泛型编程" class="headerlink" title="模版与泛型编程"></a>模版与泛型编程</h2><p>与通常函数的定义不同和类成员函数的定义不同，模板函数和类模板成员函数的定义必须全都出现在头文件当中，这样编译器才能生成一个实例化的版本。另外在编写完了模板函数的定义之后，保证对模板的调用满足模板内对参数的需求是调用者的责任，而非编写者的责任，不过模板编程应该在实现功能的基础上最小化参数需要满足的条件（或者说参数类型上已经定义的运算和操作）。</p>
<p>另外需要注意的的C++中模板关键字的作用域只绑定在其之后的第一个定义内。对之后的定义是不可见的。</p>
<p>类模板中的成员函数，若在类外进行定义需要加template声明。而且对于一个类模板，它的成员只有在真正被使用到时才会被实例化，当然实例化也发生在编译期间而非运行时。而且在模板编程时，在类模板的作用域内处理模板的引用可以省略对模板形参的显式书写。</p>
<p>在类模板内声明友元往往可以分为这几种类型：1、友元和类模板都是模板，且使用相同的模板参数，则一个模板实例会对应一个模板友元2、友元和类模板使用不同的模板参数，则不同的模板类把所有不同模板实参的友元声明为友元。3、友元不是模板，则于通常情况相似。</p>
<p>使用模板的类型成员时，需要加typename关键字显式告诉编译器这是一个类型，而非类的static成员。</p>
<p>在C++11标准中，对于类和函数模板都可以使用模板默认实参。当我们使用默认类型的模板实参时，需要在声明的模板后加一对空的尖括号。</p>
<p>C++中类的成员函数可以是模板函数，但是模板函数不能是虚函数。这时可以分为两种情况：类是模板，成员函数也是模板。类是普通类，而成员函数是模板。</p>
<p>模板的实例化发生在编译的过程中，对于一个文件来说，编译器在编译这个文件时会实例化其中用到的类模板和函数模板。这样对不同的文件可能会有相同的模板实例，这会带来一定程度的浪费。在一个文件中如下定义会实例化一个模板：template int functionname(args);并且类模板的实例化定义会实例化改模板的所有成员，包括内联得成员函数（这里有一个问题，对于哪些需要额外模板参数得成员函数，是怎么实例化得？）。</p>
<p>在模板函数类型推断时，编译器能够做的类型转换只有const转换和数组或函数到指针的转换，但是对于与模板形参无关的函数形参，编译器会正常的进行隐式类型转换。可以为函数模板显式执行模板形参的类型，类似类模板的声明那样使用尖括号即可，只是模板形参与尖括号内类型的匹配是从左到右的顺序，若没有全部显式指定，则剩下的模板实参必须可以由编译器推断出来。</p>
<p>在一些情况下当模板函数的返回类型与模板形参有关，但是却不能确定时，可以使用尾置返回类型，例如：auto function(T t1, T t2)-&gt;decltype(*t1)的方式获得T类型所引用的类型。</p>
<p>引用折叠只会发生在间接创建的引用的引用，你不能显式的书写和定义引用的引用这样的类型。</p>
<p>为了实现函数参数的完美转发，可以使用标准库std::forward设施。</p>
<p>在不同函数模板和非模板函数之间的重载，在发生调用时，它们首先是公平地在候选池当中。然后根据实际参数类型，会去推断重载的各个模板的模板参数类型，选出所有可以进行调用的模板和非模板。然后，在模板和非模板中选择最精确的匹配。如果匹配都一样精确，则选择最特例化的匹配，如果都一样特例化，则发生歧义，无法编译。</p>
<p>C++中对于不确定参数数量和类型的函数可以使用模板编写，使用…表示不定参数类型。在C++中进行不定参数编程主要使用的是包的概念。也可以与之前类似的将一个包中的所有实参进行转发，用到标准库中的std::forward设施。</p>
<p>在使用函数模板的时候，如果需要对一些参数做特殊处理，可以特例化对应的参数版本，也就是帮助编译器完成实例化某参数下的模板函数。特例化也可以使用在类模板当中，且对于类模板可以特例化一部分模板形参，此时得到的特例化还是一个模板，在使用时需要用户提供其余的模板形参。甚至可以只特例化类模板的某一个成员，这些用法都是一样的。</p>
<h1 id="第IV部分"><a href="#第IV部分" class="headerlink" title="第IV部分"></a>第IV部分</h1><h2 id="标准库特殊设施"><a href="#标准库特殊设施" class="headerlink" title="标准库特殊设施"></a>标准库特殊设施</h2><p>这一部分主要介绍了标准库中额外用到的一些设施。这些工具对于特定场景可能会由作用，不过不如标准库的stl容器和算法的那么普及，因此先做一个大概了解，明白这些设施载什么场景下会很有必要使用，在实际遇到这样的场景时，再来查阅使用。</p>
<p>其中tuple是一个模板，它的定义具有一个不定长的模板形参，可以包含容易多个不同的参数类型。通常可以使用它来让一个函数返回多个值。<br>Bitset是一个类模板，定义为一段长度的二进制位。</p>
<p>正则表达式是C++新标准库的一部分，它是一个类。往往使用一个模式来对它进行初始化，然后使用这个对象来匹配不同的字符串。</p>
<p>随机数引擎类和随机数分布类两个相互结合可以用来得到某一分布下的随机数生成引擎。</p>
<p>标准库的IO设施还可以设置一些关于输入输出的格式化参数。标准库的流设施部分支持随机访问，但是cin, cout, cerr, clog都不支持。</p>
<h2 id="用于大型程序的工具"><a href="#用于大型程序的工具" class="headerlink" title="用于大型程序的工具"></a>用于大型程序的工具</h2><p>异常处理主要是讲程序的异常检测和异常处理两部分内容分开。在程序抛出异常的时候，有一个栈展开的过程，抛出异常之后首先在当前函数的执行过程中寻找匹配的catch子句。如果异常在try中抛出，则检查与try关联的catch自居，如果不匹配，则查找嵌套该try语句的try语句所对应的catch子句，如果依然找不到则跳出函数，这跳出过程和return的机制一样，会释放所有局部变量的内存，调用所有局部变量的析构函数。并在跳出的函数当中继续寻找匹配的catch子句。一直进行展开最重要么找到匹配的处理代码，要么跳出main函数，调用标准库terminate，终止程序。因此异常在得不到解决的时候，会导致程序终止。</p>
<p>因为异常抛出之后可能会推出当前主调函数，因此如果抛出子句之后由释放函数内申请资源的代码，则这部分代码可能得不到执行，可能会导致内存泄漏，编程的时候需要注意。另外在抛出异常时，局部变量的析构函数会得到执行，如果在析构函数内又抛出异常且该异常在析构函数内得不到解决，则程序将直接推出。</p>
<p>抛出语句对象只会是静态编译类型，例如抛出一个指向基类指针的解引用，则抛出的对象将会是基类对象，无论这个指针指向的内存的动态类型式基类还是派生类。</p>
<p>因为构造函数分为初始值列表初始化和函数体两个部分，这两个部分是分先后执行的，所以当在初始值列表中出现异常时，该异常无法被函数体内的catch块捕获。为了能够捕获初始值列表初始化过程中的异常，可以把整个构造函数写为try块。</p>
<p>对一些不可能会出现异常的函数声明为noexcept的有利于帮助编译器优化代码。</p>
<p>函数指针的声明的一场说明符必须和它所指向的函数的一场说明符一致，虚函数的一场说明符会被继承下去。</p>
<p>标准库定义了一些异常类型，它们具有继承关系，最底层的类型时exception。在编写自己的程序时，可以根据需要定义自己的异常类型（从标准库异常类型继承，或者不）。另外，throw语句抛出的异常表达式会根据表达式的类型执行拷贝初始化，因此当自己定义异常类型时，需要考虑一下使用合成的拷贝构造还是自行定义。</p>
<p>在一个派生类的派生列表中可以包含多个基类，当包含两个或以上的基类时就是多重继承。在一个多重继承的派生类中包含了它所有基类的结构。一个多重继承的派生类如果准备继承构造函数，则需要对不同基类中相同参数的构造函数定义自己的版本。另外，在析构函数内，和普通继承一样，派生类只需要专注于释放自己的内存就可以。且拷贝构造函数和移动构造函数，还有拷贝赋值和移动赋值的行为都与单继承类似。</p>
<p>可以将一个将一个多重继承的类的对象绑定到它所有基类的引用或者指针上。并且这种类型转换是一样好的。当一个函数有接受这个派生类所有基类引用的版本时，接受一个派生类的对象会带来二义性错误，因为编译器无法知道应该将对象转换为什么类型。</p>
<p>在多继承下，类型成员的二义性稍微复杂一些。对于一个函数调用的解析一定是先对名字进行解析，因此编译器会对这个名字首先在派生类的成员中查找，若没有找到则在派生类的所有基类中查找，且在不同基类中查找的结果时完全公平的，无论是在基类A的基类中找到还是在基类B中找到，都是一样的重要，与继承树的深度无关。所以只要某两个以上基类中有同样的名字，则无论参数是否相同都会带来二义性。</p>
<p>可以使用虚继承来避免菱形继承时，派生类中包含多个间接基类的副本。一个类虚继承自另一个基类（假设B虚继承A），不会对这个直接派生类带来什么不同，编写它的方式与普通派生类完全一致。但是如果有一个新的类C继承自B则在C的构造函数部分需要自己初始化A的内容而不能借助B的构造函数来构造A的部分。</p>
<h2 id="特殊工具与技术"><a href="#特殊工具与技术" class="headerlink" title="特殊工具与技术"></a>特殊工具与技术</h2><p>对new和delete运算符的重载与其他运算符大不相同。New和delete的工作方式类似。对于new来说，首先调用标准库的operator new或者operator new[]来分配原始堆内存，然后再调用申请类的默认构造函数来初始化内存空间。Delete则是先调用析构，然后再用标准库操作符释放内存。程序可以重载标准库的new和delete操作符，但是必须定义在类的空间或者全局空间中，且定义在类空间中时，操作符是默认的静态的。<br>New运算符有一个定位的版本，可以在指定的起始位置开始分配内存。这应该可以用来实现内存池的技术。在程序的开始首先申请一大块原始内存，然后定义某个类自己的new操作符，然后将其定义为在预先申请的内存空间中去获取内存，并初始化。可以将申请得到的大内存空间的指针存放在类型的静态变量中 ，且实时更新已经使用的数量。</p>
<p>标准库中定义了一个可以将指向基类的指针或引用安全的转化为它所指向对象的动态类型的运算符dynamic_cast&lt;&gt;。</p>
<p>成员指针是一种有点独特的指针类型，它其实类似于成员的别名，只是使用起来需要解引用。</p>
<p>可以在一个类的定义中定义另一个类，这种类的定义叫做嵌套类，嵌套类的对象与外层类之间没有任何关系，只是在外层类的定义中，嵌套类才是可见的。可以在一个外层类中声明一个嵌套类，然后在外层类的外部定义嵌套类。但是必须加上访问说明符。</p>
<p>C++的union类型与C语言的联合类型类似。</p>
<p>与嵌套类相似的是，可以在一个函数内定义一个类，这样的类称为局部类。局部类中不能含有静态成员。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/25/C++%20primer%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" data-id="ckbugpvuf000264vw2ztna35q" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/06/25/effective%20C++%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          effective C++阅读笔记
        
      </div>
    </a>
  
  
    <a href="/2020/06/25/lue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">lue学习笔记</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/06/25/effective%20C++%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">effective C++阅读笔记</a>
          </li>
        
          <li>
            <a href="/2020/06/25/C++%20primer%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">C++ primer阅读笔记</a>
          </li>
        
          <li>
            <a href="/2020/06/25/lue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">lue学习笔记</a>
          </li>
        
          <li>
            <a href="/2020/06/15/%E6%96%B9%E4%BD%8D%E4%B8%8E%E6%AC%A7%E6%8B%89%E8%A7%92/">方位与欧拉角</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 xiongdo<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>
</html>